// ==UserScript==
// @name         High Court Date Picker with Auto-Submit, Auto-fill, Batch Tracker and Notifications
// @namespace    http://tampermonkey.net/
// @version      1.6
// @description  Complete solution with date picker, auto-fill, batch tracker, notifications and custom image/gif replacement
// @match        *://10.145.22.11:8888/weed_catalogue.php*
// @grant        GM_xmlhttpRequest
// ==/UserScript==

(function() {
    'use strict';

    // Configuration object
    const CONFIG = {
        HEART: {
            ACTIVE: {
                color: '#2ecc71',
                symbol: '‚úîÔ∏è'
            },
            INACTIVE: {
                color: '#e74c3c',
                symbol: '‚ùå'
            },
            style: {
                fontSize: '30px',
                cursor: 'pointer',
                position: 'fixed',
                bottom: '-10px',
                left: '10px',
                zIndex: '9999',
                transition: 'all 0.3s ease',
                textShadow: '2px 2px 4px rgba(0,0,0,0.2)',
                padding: '10px',
                borderRadius: '50%',
                backgroundColor: 'rgba(255,255,255,0.9)',
                boxShadow: '0 2px 5px rgba(0,0,0,0.2)',
                textAlign: 'center'
            }
        },
        BATCH_DISPLAY: {
            style: {
                display: 'inline-block',
                marginLeft: '20px',
                padding: '5px 15px',
                background: '#e8f5e9',
                color: '#2e7d32',
                borderRadius: '4px',
                fontWeight: 'bold',
                border: '1px solid #c8e6c9'
            }
        },
        IMAGES: {
            NIC_IMAGE: {
                original: 'nic.jpg',
                replacement: 'https://raw.githubusercontent.com/ravanabackup/weeding/refs/heads/main/mod.jpg'
            },
            LOADING_GIF: {
                original: 'loading.gif',
                replacement: 'https://raw.githubusercontent.com/ravanabackup/weeding/refs/heads/main/pepe-evil-plan-evil-plan.gif'
            }
        },
        TOAST: {
            CONTAINER_ID: 'toast-container',
            style: {
                position: 'fixed',
                top: '1rem',
                right: '1rem',
                zIndex: '10000'
            }
        }
    };

    // State management
    const state = {
        batchNo: '',
        rackNo: '',
        shelfNo: '',
        isDataLoaded: false,
        selectedCount: 0,
        lastNotification: {
            message: '',
            count: 0,
            timestamp: 0
        }
    };

    // Toast notification system
    function createToastContainer() {
        let container = document.getElementById(CONFIG.TOAST.CONTAINER_ID);
        if (!container) {
            container = document.createElement('div');
            container.id = CONFIG.TOAST.CONTAINER_ID;
            Object.assign(container.style, CONFIG.TOAST.style);
            document.body.appendChild(container);
        }
        return container;
    }

    function showToast(message) {
        const now = Date.now();

        // If it's the same message within 5 seconds, update count instead of showing new toast
        if (message === state.lastNotification.message &&
            (now - state.lastNotification.timestamp) < 5000) {
            state.lastNotification.count++;
            const existingToast = document.querySelector(`[data-message="${message}"]`);
            if (existingToast) {
                const countSpan = existingToast.querySelector('.notification-count');
                if (countSpan) {
                    countSpan.textContent = `(${state.lastNotification.count})`;
                    return;
                }
            }
        } else {
            state.lastNotification.message = message;
            state.lastNotification.count = 1;
            state.lastNotification.timestamp = now;
        }

        const container = createToastContainer();

        const toast = document.createElement('div');
        Object.assign(toast.style, {
            backgroundColor: 'white',
            padding: '12px 24px',
            marginBottom: '10px',
            borderRadius: '4px',
            boxShadow: '0 2px 5px rgba(0,0,0,0.2)',
            border: '1px solid #e2e8f0',
            animation: 'slideIn 0.3s ease-out',
            display: 'flex',
            alignItems: 'center',
            gap: '8px',
            color: '#2d3748',
            fontSize: '14px',
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
        });

        toast.setAttribute('data-message', message);

        toast.innerHTML = `
            <span style="margin-right: 8px;">üîî</span>
            <span>${message}</span>
            <span class="notification-count">${state.lastNotification.count > 1 ? `(${state.lastNotification.count})` : ''}</span>
        `;

        container.appendChild(toast);

        // Add animation styles if not already added
        if (!document.getElementById('toast-animations')) {
            const style = document.createElement('style');
            style.id = 'toast-animations';
            style.textContent = `
                @keyframes slideIn {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                @keyframes slideOut {
                    from {
                        transform: translateX(0);
                        opacity: 1;
                    }
                    to {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }

        // Remove toast after delay
        setTimeout(() => {
            toast.style.animation = 'slideOut 0.3s ease-in';
            toast.addEventListener('animationend', () => {
                if (container.contains(toast)) {
                    container.removeChild(toast);
                }
            });
        }, 5000);
    }

    // Image and GIF replacement function
    function replaceImages() {
        const images = document.getElementsByTagName('img');
        for (let img of images) {
            if (img.src.includes(CONFIG.IMAGES.NIC_IMAGE.original)) {
                img.src = CONFIG.IMAGES.NIC_IMAGE.replacement;
                img.style.cursor = 'pointer';
                img.addEventListener('click', () => {
                    window.open('http://10.145.22.11:8888/men.orcl', '_blank');
                });
            }
            if (img.src.includes(CONFIG.IMAGES.LOADING_GIF.original)) {
                img.src = CONFIG.IMAGES.LOADING_GIF.replacement;
            }
        }
    }

    // Add observer for dynamic image replacement
    function observeImageChanges() {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList') {
                    replaceImages();
                }
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    // Batch tracking functions
    function findLargestCJABatch() {
        let maxBatch = 0;
        const rows = document.querySelectorAll('tr');

        rows.forEach(row => {
            const locationSelect = row.querySelector('select');
            if (locationSelect) {
                const selectedOption = locationSelect.options[locationSelect.selectedIndex];
                if (selectedOption && selectedOption.text.trim().toUpperCase() === 'CJA') {
                    const batchInput = row.querySelector('input[type="text"]');
                    if (batchInput && batchInput.value) {
                        const batchNum = parseInt(batchInput.value);
                        if (!isNaN(batchNum) && batchNum > maxBatch) {
                            maxBatch = batchNum;
                        }
                    }
                }
            }
        });

        return maxBatch;
    }

    function updateBatchDisplay() {
        const largestBatch = findLargestCJABatch();
        let display = document.getElementById('maxBatchDisplay');
        if (!display) {
            display = document.createElement('div');
            display.id = 'maxBatchDisplay';
            Object.assign(display.style, CONFIG.BATCH_DISPLAY.style);
            const titleElement = document.querySelector('h2, h1, .title') || document.querySelector('body');
            if (titleElement) {
                titleElement.insertAdjacentElement('afterbegin', display);
            }
        }
        display.textContent = `Largest CJA Batch: ${largestBatch}`;
    }

    // Date picker functions
    function addDatePicker() {
        const dateButton = document.createElement('button');
        dateButton.innerHTML = 'üìÖ';
        dateButton.style.position = 'fixed';
        dateButton.style.bottom = '90px';
        dateButton.style.left = '10px';
        dateButton.style.zIndex = '9999';
        dateButton.style.padding = '8px';
        dateButton.style.borderRadius = '4px';
        dateButton.style.background = 'white';
        dateButton.style.border = '1px solid #ddd';
        dateButton.style.cursor = 'pointer';
        dateButton.onclick = toggleDatePicker;
        document.body.appendChild(dateButton);
    }

    function toggleDatePicker() {
        const existingPicker = document.getElementById('customDatePicker');
        if (existingPicker) {
            existingPicker.remove();
        } else {
            createDatePicker();
        }
    }

    function createDatePicker() {
        const picker = document.createElement('input');
        picker.type = 'date';
        picker.id = 'customDatePicker';
        picker.style.position = 'fixed';
        picker.style.bottom = '130px';
        picker.style.left = '10px';
        picker.style.zIndex = '10000';
        picker.onchange = updateDates;
        document.body.appendChild(picker);
    }

    function formatDate(dateString) {
        const date = new Date(dateString);
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}/${month}/${year}`;
    }

    function updateDates(event) {
        showToast('Updating dates...');
        const formattedDate = formatDate(event.target.value);
        const dateFromInput = document.querySelector('input[name="f_date"]');
        const dateToInput = document.querySelector('input[name="t_date"]');

        if (dateFromInput && dateToInput) {
            dateFromInput.value = formattedDate;
            dateToInput.value = formattedDate;

            triggerEvent(dateFromInput, 'change');
            triggerEvent(dateToInput, 'change');
            clickSubmitButton();
        }
    }

    function triggerEvent(element, eventType) {
        const event = new Event(eventType, { bubbles: true });
        element.dispatchEvent(event);
    }

    function clickSubmitButton() {
        const submitButton = document.querySelector('.btn.btn-success');
        if (submitButton) {
            submitButton.click();
        }
    }

    // Auto-fill functions
    function createHeartButton() {
        const heartButton = document.createElement('span');
        Object.assign(heartButton.style, CONFIG.HEART.style);
        updateHeartButtonState(heartButton);

        heartButton.addEventListener('mouseover', () => {
            heartButton.style.transform = 'scale(1.1)';
        });

        heartButton.addEventListener('mouseout', () => {
            heartButton.style.transform = 'scale(1)';
        });

        heartButton.addEventListener('click', async () => {
            if (await promptForValues()) {
                const checkedBoxes = document.querySelectorAll('input[type="checkbox"]:checked');
                checkedBoxes.forEach(checkbox => fillRowValues(checkbox.closest('tr')));
            }
        });

        return heartButton;
    }

    function updateHeartButtonState(heartButton) {
        const currentState = state.isDataLoaded ? CONFIG.HEART.ACTIVE : CONFIG.HEART.INACTIVE;
        heartButton.innerHTML = currentState.symbol;
        heartButton.style.color = currentState.color;
    }

    function fillRowValues(row) {
        if (!row) return;
        showToast('Filling row values...');

        const inputs = row.querySelectorAll('input[type="text"]');
        const values = [state.batchNo, state.rackNo, state.shelfNo];

        inputs.forEach((input, index) => {
            if (input && values[index]) {
                input.value = values[index];
                triggerEvent(input, 'change');
            }
        });

        const locationDropdown = row.querySelector('select');
        if (locationDropdown) {
            const cjaOption = Array.from(locationDropdown.options)
                .find(option => option.text.trim().toUpperCase() === 'CJA');

            if (cjaOption) {
                locationDropdown.value = cjaOption.value;
                triggerEvent(locationDropdown, 'change');
            }
        }

        updateBatchDisplay();
    }

    async function promptForValues() {
        showToast('Please enter the required values');
        const prompts = [
            { field: 'batchNo', message: 'Please enter Batch number:' },
            { field: 'rackNo', message: 'Please enter Rack number:' },
            { field: 'shelfNo', message: 'Please enter Shelf number:' }
        ];

        for (const prompt of prompts) {
            const value = window.prompt(prompt.message);
            if (value === null) return false;
            state[prompt.field] = value;
        }

        // Check if all values are '0' or blank
        const isReset = prompts.every(prompt =>
            state[prompt.field] === '0' || state[prompt.field].trim() === ''
        );

        if (isReset) {
            // Reset state
            state.batchNo = '';
            state.rackNo = '';
            state.shelfNo = '';
            state.isDataLoaded = false;
            showToast('Values have been reset');
        } else {
            state.isDataLoaded = true;
            showToast('Values loaded successfully');
        }

        const heartButton = document.querySelector('span[style*="cursor: pointer"]');
        if (heartButton) {
            updateHeartButtonState(heartButton);
        }
        return !isReset; // Return false if reset, true if valid values entered
    }

   // Counter function
    function updateCounter() {
        const prevCount = state.selectedCount;
        state.selectedCount = document.querySelectorAll('input[type="checkbox"]:checked').length;

        if (prevCount !== state.selectedCount) {
            showToast(`Selected items: ${state.selectedCount}`);
        }

        const counter = document.getElementById('selectionCounter');
        if (counter) {
            counter.textContent = `Selected: ${state.selectedCount}`;
            counter.style.backgroundColor = state.selectedCount > 0 ? '#e8f5e9' : 'rgba(255,255,255,0.9)';
            counter.style.color = state.selectedCount > 0 ? '#2e7d32' : '#34495e';
        }
    }

    // Initialize everything
    function initialize() {
        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .selection-counter {
                position: fixed;
                bottom: 50px;
                left: 10px;
                z-index: 9999;
                padding: 5px 10px;
                background: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-weight: bold;
                min-width: 80px;
                text-align: center;
            }
        `;
        document.head.appendChild(style);

        // Create counter
        const counter = document.createElement('div');
        counter.id = 'selectionCounter';
        counter.className = 'selection-counter';
        document.body.appendChild(counter);

        // Add all main elements
        replaceImages();
        observeImageChanges();
        addDatePicker();

        // Add heart button
        document.body.appendChild(createHeartButton());

        // Initial updates
        updateBatchDisplay();
        updateCounter();

        // Show welcome toast
        showToast('Script initialized successfully! üëã');

        // Add event listeners
        document.addEventListener('change', (e) => {
            if (e.target.type === 'checkbox') {
                updateCounter();
                if (state.isDataLoaded && e.target.checked) {
                    fillRowValues(e.target.closest('tr'));
                }
            }
            if (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') {
                updateBatchDisplay();
            }
        });

        // Add observer for dynamic updates
        const observer = new MutationObserver(() => {
            updateBatchDisplay();
        });

        observer.observe(document.body, {
            subtree: true,
            childList: true,
            attributes: true,
            attributeFilter: ['value']
        });
    }

    // Run initialization
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
})();
